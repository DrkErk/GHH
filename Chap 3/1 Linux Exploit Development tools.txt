TOOL: ldd (ldd /bin/ls)
	-Displays the shared libraries loaded by programs at runtime. (These libraries have a suffix of .so (shared object) and consist of individual files that contain a list of functions)
		-(The reason shared libraries are used is to promote code reusability, writing smaller programs, and making large applications easier to maintain.)
		-(attack opportunities range from finding weak file permissions and using rpath to replace shared libraries with evil ones, leaking address of shared library, and even 		  abusing its interesting gadgets to achieve execution flow control with ROP/JOP code reuse attack techniques)

TOOL: objdump
	-CLI disassembler and also can get importent information about exe files and objs.
		- "-R" option is used to display the list of functions in the GOT
		- "-M intel" tells objdump to use intel syntax mode instead of the default AT&T
		- "-d" short for "--disassemble"
		- "-j (.plt which is <section>)" specifies the section we want to display (PLT)
	-?Get good with usage, what is the usage?

-In certain situations to strings in stripped binaries to speed up debugging process (or to find magical gadgets in an object. We can find references to strings in 2 steps
	-Step 1: ■CLI: strings -tx hello|grep "6th"■ (in the example it returns ■200a 6th Edition■
		-t is for radix
		-x is for hexadecimal
		--Prints the offeset within the file at the beginning of each string
	-Step 2: ■objdump -M intel -d ./hello|grep -Cl 200a■
		
TOOL: strace
	-useful when we need to trace system calls and signals, it uses "ptrace" system call to inspect and manipulate the target problem/ helps us better understand the programs behavior/ 	 	 can be used to tamper with system calls for better trouble shooting or for faster reproduction of an attack under specific situations (fault injection, ret val injection, signal 
	 injection, delay injection).
	-(start by making sure you have the strace package. command: dpkg -l strace, then to install if needed: sudo apt install strace)
	-***Strace w/o args will display all system calls and signals***
	- -e trace=syscall if you want to trace/filter a particular system call 
	- can use -e fault=write (man it)
	-(EAGAIN) - resource temporarily unavailable error (can be injected)
	-strace can be used to inject delays
	-adding a delay example:
		-strace -e inject=read:delay_enter=1000000 \ -e inject=write:delay_exit=1000000 ./samplefile (time in microseconds)

TOOL: ltrace
	-is used to trace calls to shared libraries and their responses
	-check if you have it "dpkg -l ltrace" and install "sudo apt install ltrace" 
	- -S is used to display system calls

TOOL: checksec
	-parses a programs ELF header to determine which compile-time mitigation technologies are being used, such as RELRO, NX, Stack Canaries, ASLR and PIE.
	-this helps to identify constraints for exploitation.
	-sudo apt install checksec
	

TOOL: libc-database
	-downloads a list of configured libc versions, extracts the symbol offsets, and allows you to query the function name and leaked addresses in order to identify the libc version 	 being used
	-*** git clone https://github.com/niklasb/libc-database.git ***
	-online hosted version: https://libc.blukat.me
	-■./get kali■ a get script to get distro specific version
	-ex usage:
		-readelf to get puts offset then use the libc find script
			readelf -s /lib/x86_64-linux-gnu/libc.so.6|grep puts   --> would return <some value>
			./finds puts <some value>

TOOL: patchelf
	-cli utility allows us to modify libraries of an elf exe (useful when doing a heap analysis on a dif libc version then the one being used by the remore system or when we dont have 	 access to the source code and want to run multiple libc versions on the same systems
	- sudo apt install patchelf

TOOL: one-gadget
	-Found in libc and provide a simple way of getting a shell by jumping to a single gadget to execute "execve("/bin/sh", NULL, NULL)
	-We can find these magical gadgets one of two ways:
		-Manually using strings and objdump
		-Using the one-gadget tool
	-sudo gem install one_gadget (or on github david942j, look at extra reading to see it)


TOOL: Ropper
	-used to generate ROP chains and finding code reuse gadgets. It is capable of loading ELF, PE, Mach-o binary file formats. (suppports multiple architectures like, x86, x86_64, MIPS, 	 MIPS64, ARM/Thumb, ARM64, PowerPC, Sparc) Using the capstone disassembly framework. (IN EXTRA READINGS)	
	-sudo apt install ropper
	-***The best ability is the ability to search for gadgets based on constraints and file format conditions.***
	-can semantic search. but you must install pyvex and z3 following instructions from github (WILL BE IN EXTRA READING)
	-Jump oriented programming to stack pivoting


Extending GDB with Python
	- must be compiled --with-python
	-GEF: GDB enhanced features for exploit developers and reverse engineers
	-Pwndbg: exploit development and reverse engineering with GDB made easy
	-PEDA: Python Exploit Development Assistance for GDB

Pwntools CTF framework and exploit development library
	-Capture the flag and exploit database that allows for rapid prototyping of exploits
	-Installing Pwntools:
		sudo apt-get update
		sudo apt-get install python3 python3-pip python3-dev git libssl-dev \ libffi-dev build-essential
		sudo python3 -m pip install --upgrade pip
		sudo python3 -m pip install --upgrade pwntools

	-IN PYTHON:
	#packing/ unpacking strings
	#Assemble and Disassemble code
	#ELF symbol resolver

TOOL: leak-bof.c
	-appears to work in conjunction of running code vulnerable to buffer overflow and pwntools python program to find gadgets look at page 67 to see the example


TOOL: HeapME
	-Open source tool developed to help simplify the process of heap analysis and collaboration
	-Features:
		-timeless heap debugging
		-tracking of all chunks/ free bins states
		-seamless analysis collaboration
		-shared link for read only visualization
		-(great for ctfs)
		-support for ptmalloc2 in current version
	-at: https://heapme.f2tc.com/5ebd655bdadff500194aab4f is an example

	-how to install:
		-make sure gdb is installed (dpkg -l gdb)
		- sudo apt install gdb
		-NEXT, GET THE GEF FORK OF GDB with the HeapME plugin (IN THE FURTHER READING UNDER CHAP 3)
	
	-the lab:
	-begin, create/ compile the heapme_demo.c
		-use the gdb to debug the heapme_demo program
		-execute the gdb command start
		-launch the GEF heap analysis helper plugin
		-go to heapme website (https://heapme.f2tc.com/)
			-register and login
			-create and copy a new heapme url and key
			-once copied click the next button
		-go back to gdb and paste in the line: heapme init https://heapme.f2tc.com/<id><key>
		-use 'heapme watch malloc' and 'heapme watch free' to update all heap chunks and free bins whenever these breakpoints are hit.
		-execute 'c' or 'continue'. (there should be realtime heapme url updating) (good time to play with gef heap commands(heap bins, heap chunks, etc) 


	



 






































